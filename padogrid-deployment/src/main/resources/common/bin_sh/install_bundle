#!/usr/bin/env bash 

# ========================================================================
# Copyright (c) 2020-2023 Netcrest Technologies, LLC. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ========================================================================

SCRIPT_DIR="$(cd -P -- "$(dirname -- "$0")" && pwd -P)"
. $PADOGRID_HOME/$PRODUCT/bin_sh/.addonenv.sh

EXECUTABLE="`basename $0`"

__options()
{
   echo "-user -githost -branch -tag -release -connect -preview -download -checkout -workspace -replace -force -overwrite-workspace -init -quiet -?"
}

if [ "$OPTIONS" == "true" ]; then
   __options
   exit
fi

if [ "$HELP" == "true" ]; then
cat <<EOF

WORKSPACE
   $PADOGRID_WORKSPACE

NAME
   $EXECUTABLE - Install the specified bundle file in the current workspace

WARNING
   Depending on the options specified, this command may overwrite the files in the
   current padogrid workspace that have the same paths. As a safety measure, it will
   back up the workspace by executing the 'create_bundle -all' command before  installing
   the specified bundle.

SYNOPSIS
   $EXECUTABLE [-user git_user_name]
                  [-githost github | gitea]
                  [-branch git_branch | -tag git_tag] 
                  [-tag git_tag] 
                  [-connect https | ssh]
                  [-checkout default | workspace_name]
                  [-workspace default | workspace_name]
                  [-replace sed_substitution_expression]
                  [-preview] [-download] [-force] [-overwrite-workspace] [-init]
                  [-quiet] [-?] bundle_file_path

DESCRIPTION
   Installs the specified bundle file in the specified padogrid workspace. If the target
   workspace exists and has running processes, then make sure to terminate all of the
   conflicting processes before executing this command; otherwise, the running processes
   may result in unpredictable state.

   For online bundles, if the '-init' option is specified and the '.init_workspace.sh' script
   exists in the top directory, then it is sourced in upon completion of bundle workspace
   installation. A bundle workspace is installed with the following options.

      install_bundle -checkout -init
      install_bundle -workspace -download -init

   If your local environment does not have access to the Internet, then you can install
   the online bundles by manually downloading them. Download the zip files from the
   repos and execute this command. See examples below.

OPTIONS
   -user git_user_name
             Git user name. If specified, then it downloads the specified bundle from user's
             Git repos.

   -githost github | gitea
             Git host. Supported git hosts are 'github' and 'gitea'. Default: github.

   -branch git_branch
             Git branch to download. If not specified then the default branch is downloaded.

   -release git_release
             Git release version to download. If not specified then the default branch is downloaded.

   -tag git_tag
             Git tag to download. If not specified then the default branch is downloaded.

   -connect https | ssh
             Git connection type. For GitHub, the default is 'https'. To connect to private repos,
             for 'ssh', you must first deploy your public key, e.g., '~/.ssh/id_rsa.pub', to your
             repo account, and for 'https', generate a personal access token from the repo account.
             Please see GitHub or Gitea documentation for details.

             To make 'ssh' default, set GITHUB_PRIVATE_REPO_ENABLED to "true" in the
             '~/.padogrid/setenv.sh' file as shown below.

             GITHUB_PRIVATE_REPO_ENABLED="true"

   -preview
             Do not install but display the bundle contents.

   -download
             Downloads and installs the specified bundle from the remote padogrid bundle repo. To
             prevent it from installing, specify the '-preview' option.  If the '-preview' option is
             specified, then it downloads and displays the contents but does not install the bundle.
             You can install the downloaded bundle later by specifying the bundle file path.

   -checkout default | workspace_name
             If this option is specified then it checks out the bundle in the specified workspace.
             If workspace_name is 'default' or unspecified then the bundle name is used as the workspace
             name.  The new workspace it creates clones the same configuration as the current workspace. 
             The '-download' option is not necessary for this option as it always downloads the bundle
             from the repo.

   -workspace default | workspace_name
             If this option is specified then it installs the bundle in the specified workspace.
             If workspace_name is 'default' or unspecified then the bundle name is used as the workspace
             name. The new workspace it creates clones the same configuration as the current workspace. 

   -all
             Installs all bundles as workspace bundles. This option should be used in a new empty RWE
             to avoid workspace conflicts. It only applies to '-checkout' and '-download -workspace'.
             'workspace_name' and 'bundle_file_path' are ignored. See examples below.

   -replace "sed_substitution_expression"
             A 'sed' expression for substituting workspace names. This option allows renaming of
             the long bundle names with more appropriate workspace names. It has the format of
             '/from_exp/to_exp/' which translates to "sed 's/from_exp/to_exp/'". For example,
             the following removes the prefix 'bundle-' from workspace names.

             -replace "/bundle-//"

             If spaces are in the substitition expression then the entire expression  must be
             in double quotes.

             This option is allowed only if the '-all' option is specified.

   -force
             If specified, then it overrides the product version check step and installs the 
             specified bundle. Normally, '$EXECUTABLE' aborts if the current workspace is
             is not configured with the required product version by the bundle. This option
             is useful if you are only interested in viewing the bundle contents. The required
             product version can be installed later as needed to run the bundle.

   -overwrite-workspace
             If specified, then overwrites the existing workspace. This option is meaningful only if
             the '-checkout' or '-download -workspace' option is also specified. Without this option,
             by default, this command aborts if the workspace already exists. Note that it does not
             overwrite git artifacts.

   -init
             If specified, then for bundle workspace installation, the '.init_workspace.sh' script
             is sourced in if it exists.

   -quiet
             Quiet mode. Supresses the interactive prompt.

   bundle_file_path
              Bundle file path if local or bundle name if download. If the bundle file name ends with
              the .zip extension, then it assumes the bundle file was downloaded from the repo and
              installs the bundle accordingly.

DEFAULT
   $EXECUTABLE -user padogrid -githost github

EXAMPLES
   To list remote bundles:
      $EXECUTABLE

   To preview a remote bundle:
      $EXECUTABLE -download -preview bundle-none-imdg-benchmark-tests

   To install a remote bundle:
      $EXECUTABLE -download bundle-none-imdg-benchmark-tests

   To install a remote bundle as a workspace:
      $EXECUTABLE -download -workspace bundle-none-imdg-benchmark-tests

   To overwrite an existing workspace:
      $EXECUTABLE -download -workspace myws bundle-none-imdg-benchmark-tests

   To install all remote bundles as workspaces:
      $EXECUTABLE -all -download -workspace

   To check out a remote bundle as a workspace:
      $EXECUTABLE -checkout bundle-none-imdg-benchmark-tests

   To check out all bundles as workspaces:
      $EXECUTABLE -all -checkout

   To install a downloaded zip file.
      $EXECUTABLE bundle-hazelcast-4n5-cluster-session-master.zip
      $EXECUTABLE -workspace bundle-hazelcast-4n5-cluster-session-master.zip
      $EXECUTABLE -workspace mysession bundle-hazelcast-4n5-cluster-session-master.zip
      
EOF
if [ "$MAN_SPECIFIED" == "false" ]; then
cat <<EOF
FILES
   $PADOGRID_WORKSPACE/bundles
             The current workspace bundles directory where locally generated bundles are stored.

   To install all remote bundles as workspaces:
      $EXECUTABLE -all -download -workspace

   To check out a remote bundle as a workspace:
      $EXECUTABLE -checkout bundle-coherence-14-app-perf_test_wan-cluster-ln-ny

   To check out all bundles as workspaces:
      $EXECUTABLE -all -checkout

   To install a downloaded zip file.
      $EXECUTABLE bundle-hazelcast-4n5-cluster-session-master.zip
      $EXECUTABLE -workspace bundle-hazelcast-4n5-cluster-session-master.zip
      $EXECUTABLE -workspace mysession bundle-hazelcast-4n5-cluster-session-master.zip
      
EOF
fi
if [ "$MAN_SPECIFIED" == "false" ]; then
cat <<EOF
FILES
   $PADOGRID_WORKSPACE/bundles
             The current workspace bundles directory where locally generated bundles are stored.
EOF
fi
cat <<EOF

SEE ALSO
EOF
   printSeeAlsoList "*bundle*" $EXECUTABLE
   exit
fi

if [ "$1" == "" ]; then
   LIST="true"
fi
if [ "$LIST" == "true" ]; then
   show_bundle -list
   exit
fi

BUNDLE_FILE_PATH="$LAST_ARG"

# Set WORKSPACE_NAME. (due to the arg parser limitations, we need to do this here)
if [ "$CHECKOUT_ARG" == "" ] || [[ "$CHECKOUT_ARG" == "-"* ]] || [ "$CHECKOUT_ARG" == "$BUNDLE_FILE_PATH" ]; then
   if [ "$CHECKOUT_ARG" == "-download" ]; then
      DOWNLOAD="true"
   elif [ "$CHECKOUT_ARG" == "-preview" ]; then
      PREVIEW="true"
   fi
   WORKSPACE_NAME="default"
else
   WORKSPACE_NAME=$CHECKOUT_ARG
fi
if [ "$CHECKOUT_SPECIFIED" == "true" ]; then
   DOWNLOAD="true"
fi
if [ "$WORKSPACE_NAME" == "" ] || [ "$WORKSPACE_NAME" == "default" ]; then
   if [ "$WORKSPACE_ARG" == "" ] || [[ "$WORKSPACE_ARG" == "-"* ]] || [ "$WORKSPACE_ARG" == "$BUNDLE_FILE_PATH" ]; then
      if [ "$WORKSPACE_ARG" == "-download" ]; then
         DOWNLOAD="true"
      elif [ "$WORKSPACE_ARG" == "-preview" ]; then
         PREVIEW="true"
      fi
      WORKSPACE_NAME="default"
   else
      WORKSPACE_NAME=$WORKSPACE_ARG
   fi
fi

# Exit if both -replace and workspace name specified
if [ "$REPLACE_ARG" != "" ] && [ "$CHECKOUT_ARG" != "" ] &&  [ "$CHECKOUT_ARG" != "$BUNDLE_FILE_PATH" ]; then
  echo -e "${CLightRed}ERROR:${CNone} '-replace' and workspace name are not allowed together. Command aborted."
  exit 1
fi
if [ "$REPLACE_ARG" != "" ] && [ "$WORKSPACE_ARG" != "" ] &&  [ "$WORKSPACE_ARG" != "$BUNDLE_FILE_PATH" ]; then
  echo -e "${CLightRed}ERROR:${CNone} '-replace' and workspace name are not allowed together. Command aborted."
  exit 1
fi

# Exit if -replace expression is invalid
SED_SUB_EXPRESSION="$REPLACE_ARG"
if [ "$SED_SUB_EXPRESSION" != "" ]; then
   if [[ "$SED_SUB_EXPRESSION" != "/"* ]] || [[ "$SED_SUB_EXPRESSION" != *"/" ]]; then
      echo -e >&2 "${CError}ERROR:${CNone} Invalid sed substitution expression: [$SED_SUB_EXPRESSION]. Must begin and end with '/'. Command aborted."
      exit 2
   fi
   WORKSPACE_NAME=$(echo $BUNDLE_FILE_PATH | sed "s$SED_SUB_EXPRESSION")
fi

# Exit if both -branch and -tag are specified
num_opts=0
if [ "$BRANCH" != "" ]; then 
   num_opts=$((num_opts + 1))
fi
if [ "$RELEASE" != "" ]; then 
   num_opts=$((num_opts + 1))
fi
if [ "$TAG" != "" ]; then 
   num_opts=$((num_opts + 1))
fi

if [ $num_opts -gt 1 ]; then
   echo -e >&2 "${CError}ERROR:${CNone} '-branch', '-release', and '-tag' are not allowed together. Command aborted."
   exit 1
fi

BRANCH_TAG_RELEASE=""
if [ "$BRANCH" != "" ]; then
   BRANCH_TAG_RELEASE="$BRANCH"
elif [ "$TAG" != "" ]; then
   BRANCH_TAG_RELEASE="$TAG"
elif [ "$RELEASE" != "" ]; then
   BRANCH_TAG_RELEASE="$RELEASE"
fi

#
# Handle -all:w
#
OPTIONS_BY=""
OPTIONS="$@" 
if [ "$ALL_SPECIFIED" == "true" ]; then
  if [[ "$BUNDLE_FILE_PATH" != "-"* ]]; then
     echo -e "${CLightRed}ERROR:${CNone} Invalid options. Bundle name not allowed with '-all'. Command aborted."
     exit 1
  fi

  if [ "$CHECKOUT_SPECIFIED" == "true" ]; then
     OPTIONS_BY="-checkout"
  else
     if [ "$DOWNLOAD" == "true" ] && [ "$WORKSPACE_SPECIFIED" == "true" ]; then
        OPTIONS_BY="-download -workspace"
     else
        echo -e "${CLightRed}ERROR:${CNone} '-all' requires '-checkout' or '-download -workspace'. Command aborted."
        exit 1
     fi
  fi
  if [ "$FORCE_SPECIFIED" == "true" ]; then
     OPTIONS_BY="$OPTIONS_BY -force"
  fi
  echo ""
  echo "Installing all bundles [$OPTIONS_BY]..."
  ALL_BUNDLES="$(show_bundle -no-color $@ | grep "^\[" | sed 's/.*\]//')"
  OPTIONS="$@"
  # Remove '-all' from the argument list
  OPTIONS=$(trimString "$(echo $OPTIONS | sed 's/-all//g')")

  # Recursively execute this command per bundle
  for BUNDLE_NAME in $ALL_BUNDLES; do
     echo "--------------------------------------------------------------------------"
     echo -e "install_bundle $OPTIONS ${CBrownOrange}${BUNDLE_NAME}${CNone}"
     install_bundle $OPTIONS $BUNDLE_NAME
     echo "--------------------------------------------------------------------------"
  done
  echo ""
  echo "Please check ERROR messages. Some of the bundles may have not been installed"
  echo "due to product version discrepencies. To install them, you need to first"
  echo "install the correct product versions." 
  echo ""
  echo "Bundle installations complete."
  echo ""
  exit
fi

#
# Handle non-all
#
DOWNLOADED_BUNDLE_FILE_SPECIFIED=false
if [[ $BUNDLE_FILE_PATH == *.zip ]]; then
   DOWNLOADED_BUNDLE_FILE_SPECIFIED=true
   DOWNLOADED_BUNDLE_FILE_NAME=$(basename $BUNDLE_FILE_PATH)
   DOWNLOADED_BUNDLE_NAME=${DOWNLOADED_BUNDLE_FILE_NAME%.zip}
   BUNDLE_NAME=${DOWNLOADED_BUNDLE_NAME%-master}
else
   BUNDLE_NAME=$BUNDLE_FILE_PATH
fi


#
# Returns "true" if one of the specfied product versions match the configured product version.
#
# @param product        Product name in lowercase. Valid values are hazelcast, hazecast-enterprise,
#                       jet, jet-enterprise, geode, gemfire, snappydata, spark, coherence, pado, redis.
# @param productHome    Product home path, e.g. $HAZELCAST_HOME.
# @param productVersion Product versions, e.g., "3,4"
#
function isProductExist
{
   local product=$1          # hazelcast
   local productHome=$2     # HAZELCAST_HOME
   local productVersions=$3 # 3,4
   local found="false"
   local IFS=','
   for token in $productVersions; do
      if [ "$product" == "hazelcast-enterprise" ] && [[ "$productHome" == *"hazelcast-enterprise-$token"* ]]; then
         found="true"
         break;
      elif [ "$product" == "jet-enterprise" ] && [[ "$productHome" == *"jet-enterprise-$token"* ]]; then
         found="true"
         break;
      elif [ "$product" == "mosquitto" ]; then
         # Check if mosquitto is installed in the system directory
         if [ "$MOSQUITTO_HOME" == "" ]; then
            if [ "$(which mosquitto 2> /dev/null)" != "" ]; then
               version=$(mosquitto -h | grep version | awk '{print $3}')
               if [[ "$version" == "$productVersion"* ]]; then
                  found="true"
                  break;
               fi
            fi
         elif [[ "$productHome" == *"$token"* ]]; then
            found="true"
            break;
         fi
      elif [[ "$productHome" == *"$token"* ]]; then
         found="true"
         break;
      fi
   done
   unset IFS
   echo "$found"
}

#
# Returns key/value product pair for the specified bundle name.
#
# Example:
#    getProductKeyValue "bundle-hazelcast-3n4-app-pado"
#    hazelcast=3,4 
# 
# @param bundleName Bundle name
#
function getProductKeyValue
{
   local bundleName=$1
   if [[ "$bundleName" != "bundle-"* ]]; then
      echo ""
   else
      local product=${bundleName#bundle-}
      product=${product%%-*}
      version=${bundleName#bundle-$product-}
      version=${version#training-}
      version=${version%%-*}
      if [ "$version" == "bundle" ]; then
         echo "$product="
      else
         version=${version//n/,} 
         echo "$product=$version"
      fi
   fi
}

#
# Creates .cluster/clusterenv.sh in all bundle clusters. This function is to support the deprecated
# bundle installation method which relied on a single product/cluster type per workspace. This only
# addresses a bundle with a single type.
# 
# @required PRODUCT
# @required CLUSTERS
# @required WORKSPACE_PATH
# @required CLUSTER_TYPE
#
function createClusterEnv
{
   __PRODUCT=${PRODUCT%%-enterprise}
   for cluster in $CLUSTERS; do
      CLUSTER_DIR="$WORKSPACE_PATH/clusters/$cluster"
      if [ ! -d "$CLUSTER_DIR/.cluster" ]; then
         mkdir "$CLUSTER_DIR/.cluster"
         echo "PRODUCT=$__PRODUCT" > "$CLUSTER_DIR/.cluster/clusterenv.sh"
         echo "CLUSTER_TYPE=$CLUSTER_TYPE" >> "$CLUSTER_DIR/.cluster/clusterenv.sh"
      fi
    done
}

if [ "$OVERWRITE_WORKSPACE_SPECIFIED" == "true" ] && [ "$CHECKOUT_SPECIFIED" == "true" ]; then
   echo -e >&2 "${CLightRed}ERROR:${CNone} '-overwrite-workspace' and '-checkout' are not allowed together. Command aborted."
   exit 1
fi

IS_BUNDLE_WORKSPACE="false"
if [ "$CHECKOUT_SPECIFIED" == "true" ] || [ "$WORKSPACE_SPECIFIED" == "true" ]; then
   IS_BUNDLE_WORKSPACE="true"
fi

if [ "$DOWNLOADED_BUNDLE_FILE_SPECIFIED" == "true" ]; then
   if [ "$CHECKOUT_SPECIFIED" == "true" ]; then
      echo -e >&2 "${CLightRed}ERROR:${CNone} Invalid options. '-checkout' not allowed with a zip file. Command aborted."
      exit 1
   fi
   if [ "$DOWNLOAD" == "true" ]; then
      echo -e >&2 "${CLightRed}ERROR:${CNone} Invalid options. '-download' not allowed with a zip file. Command aborted."
      exit 1
   fi
fi

if [ "$CHECKOUT_SPECIFIED" == "true" ] && [ "$WORKSPACE_SPECIFIED" == "true" ]; then
   echo -e >&2 "${CLightRed}ERROR:${CNone} Invalid options. Specify either '-checkout' or '-workspace'. Command aborted."
   exit 1
fi

# Handle the -release option. Download the release and set the DOWNLOADED* variables
# to install.
if [ "$RELEASE" != "" ]; then
   BUNDLE_DIR=$PADOGRID_WORKSPACE/bundles
   if [ ! -d $BUNDLE_DIR ]; then
      mkdir -p $BUNDLE_DIR
   fi
   PADOGRID_URL="https://github.com/padogrid"
   BUNDLE_FILE_PATH=$BUNDLE_DIR/$BUNDLE_NAME-${RELEASE}.zip
   curl -sL -o $BUNDLE_FILE_PATH $PADOGRID_URL/$BUNDLE_NAME/archive/refs/tags/${RELEASE}.zip
   if [ "$(file $BUNDLE_FILE_PATH | grep -i ASCII)" != "" ]; then
      rm $BUNDLE_FILE_PATH
      echo -e >&2 "${CLightRed}ERROR:${CNone} The specified release does not exist: [$RELEASE]. Command aborted."
      exit 1
   else
      DOWNLOADED_BUNDLE_FILE_SPECIFIED=true
      DOWNLOADED_BUNDLE_FILE_NAME=$(basename $BUNDLE_FILE_PATH)
      DOWNLOADED_BUNDLE_NAME=${DOWNLOADED_BUNDLE_FILE_NAME%.zip}
   fi
fi

# Set arguments
if [ "$USER" == "" ]; then
   GITHUB_USER="padogrid"
else
   GITHUB_USER="$USER"
fi

if [ "$DOWNLOAD" == "true" ] || [ "$DOWNLOADED_BUNDLE_FILE_SPECIFIED" == "true" ]; then
   IS_DOWNLOAD="true"
   REPO_NAME=""
   if [ "$IS_BUNDLE_WORKSPACE" == "true" ]; then
      if [ "$WORKSPACE_NAME" != "default" ]; then
         REPO_NAME="$WORKSPACE_NAME"
      else
         REPO_NAME="$BUNDLE_NAME"
      fi
      GIT_DIR="$PADOGRID_WORKSPACES_HOME/$REPO_NAME"
      if [ "$OVERWRITE_WORKSPACE_SPECIFIED" == "false" ] && [ -d "$GIT_DIR" ]; then
         echo -e >&2 "${CLightRed}ERROR:${CNone} The specified bundle workspace already exists: [$REPO_NAME]. Specify '-overwrite-workspace' to overwrite. Command aborted."
         exit 1
      elif [ "$OVERWRITE_WORKSPACE_SPECIFIED" == "true" ]; then
         if [ -d "$GIT_DIR/.git" ] ; then
            echo -e >&2 "${CLightRed}ERROR:${CNone} The specified bundle workspace is already checked out. Overwriting checked-out"
            echo -e >&2 "       workspaces is not permitted. Command aborted."
            exit 1
         fi
         # If the workspace directory does not exist then explicitly disable overwrite. This needs
         # to be done here due to the conflicting overwrite logic later in this script.
         if [ ! -d "$GIT_DIR" ]; then
            OVERWRITE_WORKSPACE_SPECIFIED="false"
         fi
      fi
   else
      GIT_DIR=$PADOGRID_WORKSPACE/bundles/$BUNDLE_NAME
      TARBALL=${BUNDLE_NAME}.tar.gz
   fi
   TARBALL_PATH=$PADOGRID_WORKSPACE/bundles/$TARBALL
   if [ "$QUIET" == "false" ] && [ -f "$TARBALL_PATH" ] && [ "$DOWNLOADED_BUNDLE_FILE_SPECIFIED" == "false" ]; then
      echo "The specified bundle exists in the bundles directory."
      echo "   $PADOGRID_WORKSPACE/bundles/$TARBALL"
      REDO=true
      INNER_LOOP=true
      while [ "$INNER_LOOP" == "true" ]; do
         read -p "Enter 'e' to install the existing bundle, 'd' to download, 'q' to quit: " INPUT
         case $INPUT in
            [Ee]* ) IS_DOWNLOAD="false"; INNER_LOOP=false;;
            [Dd]* ) IS_DOWNLOAD="true"; INNER_LOOP=false;;
            [Qq]* ) echo "Command Aborted."; INNER_LOOP=false; exit;; * ) INNER_LOOP=true;;
         esac
      done
   fi
   if [ "$IS_DOWNLOAD" == "true" ]; then
      if [ "$IS_BUNDLE_WORKSPACE" == "false" ]; then
         if [ -d "$GIT_DIR" ]; then
            rm -rf $GIT_DIR
         fi
      fi

      # Source in .padogrid/setenv.sh
      SETENV_FILE="$HOME/.padogrid/setenv.sh"
      if [ -f "$SETENV_FILE" ]; then
         . $SETENV_FILE
      fi

      REQUIRED_PRODUCTS_FILE_PATH=/tmp/required_products.txt
      if [ "$DOWNLOADED_BUNDLE_FILE_SPECIFIED" == "true" ]; then
         pushd $PADOGRID_WORKSPACE/bundles > /dev/null 2>&1 
         jar xf $BUNDLE_FILE_PATH

         if [ ! -d "$DOWNLOADED_BUNDLE_NAME" ]; then
            echo -e >&2 "${CLightRed}ERROR:${CNone} Invalid bundle zip file. Command aborted."
            exit 1
         else
            if [ "$DOWNLOADED_BUNDLE_NAME" != "$BUNDLE_NAME" ]; then
               mv $DOWNLOADED_BUNDLE_NAME $BUNDLE_NAME
            fi
            #if [ -f $BUNDLE_NAME/required_products.txt ]; then
            #   cp $BUNDLE_NAME/required_products.txt .
            #fi
            # Make all scripts in bin_sh executable
            for i in $(find $BUNDLE_NAME -name bin_sh); do
               if [ -d $i ]; then
                  chmod 755 $i/*
               fi
            done

            if [ "$IS_BUNDLE_WORKSPACE" == "true" ]; then
               if [ "$WORKSPACE_NAME" == "default" ]; then
                  mv $BUNDLE_NAME $PADOGRID_WORKSPACES_HOME/
               else
                  mv $BUNDLE_NAME $PADOGRID_WORKSPACES_HOME/$WORKSPACE_NAME
               fi
            fi
         fi
         popd > /dev/null 2>&1 
      else
         if [ "$GITHOST" == "gitea" ]; then
            GITHUB_USER_HOME="$GITEA_SSH_URL:$GITHUB_USER"
            USER_REPOS_URL="$GITEA_HTTPS_URL/api/v1/user/repos"
            REPOS_URL="$GITEA_HTTPS_URL/api/v1/repos"
            AUTH_HEADER="Authorization: token $GITEA_ACCESS_TOKEN"
            REQUIRED_PRODUCTS_CONTENT_URL="$REPOS_URL/$GITHUB_USER/${BUNDLE_FILE_PATH}/contents/required_products.txt"
            curl -sS -X GET "$REQUIRED_PRODUCTS_CONTENT_URL" -H "$AUTH_HEADER" | grep -o "\"content\":\"[^\"]*" | sed 's/"content":"//' | base64 -d > $REQUIRED_PRODUCTS_FILE_PATH 2>/dev/null
         else
            if [ "$CONNECT_ARG" == "https" ]; then
                GITHUB_USER_HOME="https://github.com/$GITHUB_USER"
            elif [ "$CONNECT" == "ssh" ] || [ "$GITHUB_PRIVATE_REPO_ENABLED" == "true" ]; then
                GITHUB_USER_HOME="git@github.com:$GITHUB_USER"
            else
                GITHUB_USER_HOME="https://github.com/$GITHUB_USER"
            fi
            RAW_REQUIRED_PRODUCTS_URL=https://raw.githubusercontent.com/$GITHUB_USER/$BUNDLE_FILE_PATH/master/required_products.txt
            curl -sS $RAW_REQUIRED_PRODUCTS_URL > $REQUIRED_PRODUCTS_FILE_PATH 2>/dev/null
         fi
      fi

      # Use the bundle name as the workspace name if it is not specified.
      if [ "$WORKSPACE_NAME" == "default" ]; then
         if [ "$IS_BUNDLE_WORKSPACE" == "true" ]; then
            WORKSPACE_NAME=$BUNDLE_NAME
         fi
      fi
      
      declare -a requiredProducts
      declare -a clusterTypes
      declare -a propArray
      if [ -f "$REQUIRED_PRODUCTS_FILE_PATH" ]; then
         getPropertiesArray "$REQUIRED_PRODUCTS_FILE_PATH" propArray
         rm "$REQUIRED_PRODUCTS_FILE_PATH"
      fi
      let len=${#propArray[@]}
      if [ $len -eq 0 ]; then
         echo "Using the bundle name to determine installed products..."
      
         #
         # Make sure the bundle can be installed in the current environment.
         #
         file_name="`basename $BUNDLE_FILE_PATH $0`"
         keyvalue=$(getProductKeyValue "$file_name")
      
         if [[ "$keyvalue" != "coherence"* ]] \
            && [[ "$keyvalue" != "gemfire"* ]] \
            && [[ "$keyvalue" != "geode"* ]] \
            && [[ "$keyvalue" != "hadoop"* ]] \
            && [[ "$keyvalue" != "hazelcast"* ]] \
            && [[ "$keyvalue" != "jet"* ]] \
            && [[ "$keyvalue" != "kafka"* ]] \
            && [[ "$keyvalue" != "confluent"* ]] \
            && [[ "$keyvalue" != "mosquitto"* ]] \
            && [[ "$keyvalue" != "none"* ]] \
            && [[ "$keyvalue" != "redis"* ]] \
            && [[ "$keyvalue" != "snappydata"* ]] \
            && [[ "$keyvalue" != "spark"* ]]; then
            echo -e >&2 "${CLightRed}ERROR:${CNone} Unsupported bundle product name [$keyvalue]. Command aborted."
            exit 1
         fi
         propArray[0]=$keyvalue
      fi
      
      # Determine if the required product versions are available.
      let len=${#propArray[@]}
      declare -a unfoundProducts
      NONE_FOUND="false"
      if [ $len -gt 0 ]; then
         let last_index=len-1
         for i in $(seq 0 $last_index); do
            keyvalue=${propArray[$i]}
            PRODUCT=${keyvalue%%=*}
            PRODUCT_VERSIONS=${keyvalue#*=}
            found="false"

            # If product version is not specified then treat it as none
            if [[ ! $PRODUCT_VERSIONS =~ [0-9].* ]]; then
               PRODUCT="none"
               PRODUCT_VERSIONS=1
            fi

            CLUSTER_TYPE=""
            if [ "$PRODUCT" == "coherence" ]; then
               found=$(isProductExist "$PRODUCT" "$COHERENCE_HOME" "$PRODUCT_VERSIONS")
               CLUSTER_TYPE="coherence"
            elif [ "$PRODUCT" == "gemfire" ]; then
               found=$(isProductExist "$PRODUCT" "$GEMFIRE_HOME" "$PRODUCT_VERSIONS")
               CLUSTER_TYPE="gemfire"
            elif [ "$PRODUCT" == "geode" ]; then
               found=$(isProductExist "$PRODUCT" "$GEODE_HOME" "$PRODUCT_VERSIONS")
               CLUSTER_TYPE="geode"
            elif [ "$PRODUCT" == "hadoop" ]; then
               found=$(isProductExist "$PRODUCT" "$HADOOP_HOME" "$PRODUCT_VERSIONS")
               CLUSTER_TYPE="pseudo"
            elif [ "$PRODUCT" == "hazelcast" ]; then
               found=$(isProductExist "$PRODUCT" "$HAZELCAST_HOME" "$PRODUCT_VERSIONS")
               CLUSTER_TYPE="imdg"
            elif [ "$PRODUCT" == "hazelcast-enterprise" ]; then
               found=$(isProductExist "$PRODUCT" "$HAZELCAST_HOME" "$PRODUCT_VERSIONS")
               CLUSTER_TYPE="imdg"
            elif [ "$PRODUCT" == "jet" ]; then
               found=$(isProductExist "$PRODUCT" "$JET_HOME" "$PRODUCT_VERSIONS")
               CLUSTER_TYPE="jet"
            elif [ "$PRODUCT" == "jet-enterprise" ]; then
               found=$(isProductExist "$PRODUCT" "$JET_HOME" "$PRODUCT_VERSIONS")
               CLUSTER_TYPE="jet"
            elif [ "$PRODUCT" == "kafka" ]; then
               found=$(isProductExist "$PRODUCT" "$KAFKA_HOME" "$PRODUCT_VERSIONS")
               CLUSTER_TYPE="kafka"
            elif [ "$PRODUCT" == "confluent" ]; then
               found=$(isProductExist "$PRODUCT" "$CONFLUENT_HOME" "$PRODUCT_VERSIONS")
               CLUSTER_TYPE="confluent"
            elif [ "$PRODUCT" == "mosquitto" ]; then
               found=$(isProductExist "$PRODUCT" "$MOSQUITTO_HOME" "$PRODUCT_VERSIONS")
               CLUSTER_TYPE="mosquitto"
            elif [ "$PRODUCT" == "none" ]; then
               found=true
               CLUSTER_TYPE="none"
               NONE_FOUND="true"
            elif [ "$PRODUCT" == "pado" ]; then
               found=$(isProductExist "$PRODUCT" "$PADO_HOME" "$PRODUCT_VERSIONS")
            elif [ "$PRODUCT" == "snappydata" ]; then
               found=$(isProductExist "$PRODUCT" "$SNAPPYDATA_HOME" "$PRODUCT_VERSIONS")
               CLUSTER_TYPE="snappydata"
            elif [ "$PRODUCT" == "spark" ]; then
               found=$(isProductExist "$PRODUCT" "$SPARK_HOME" "$PRODUCT_VERSIONS")
               CLUSTER_TYPE="standalone"
            elif [ "$PRODUCT" == "redis" ]; then
               found=$(isProductExist "$PRODUCT" "$REDIS_HOME" "$PRODUCT_VERSIONS")
               CLUSTER_TYPE="redis"
            fi
            if [ "$found" == "true" ]; then
                requiredProducts[$i]=$PRODUCT
                clusterTypes[$i]=$CLUSTER_TYPE
            else
                unfoundProducts[$i]=$keyvalue
            fi
         done
      fi

      # Exit if there are unfound versions. none overrides all.
      if [ "$FORCE_SPECIFIED" == "false" ] && [ "$NONE_FOUND" == "false" ]; then
         let unfound_len=${#unfoundProducts[@]}
         if [ $unfound_len -gt 0 ]; then
            let last_index=len-1
            echo -e >&2 "${CLightRed}ERROR:${CNone} This bundle requires the following product version(s) configured for the workspace."
            for i in $(seq 0 $last_index); do
               if [ "${unfoundProducts[$i]}" != "" ]; then
                  echo >&2 "          ${unfoundProducts[$i]}"
               fi
            done
            echo >&2 ""
            echo >&2 "       Specified the '-force' option to override the product version or"
            echo >&2 "       use the following commands to verify and install products."
            echo >&2 "          show_products, update_products, install_products"
            echo >&2 ""
            echo >&2 "       Command aborted."
            exit 1
         fi
      fi
      
      if [ "$DOWNLOADED_BUNDLE_FILE_SPECIFIED" == "true" ]; then
         pushd $GIT_DIR > /dev/null 2>&1 
         mvn package
         # Make all scripts in bin_sh executable
         for i in $(find . -name bin_sh); do
            if [ -d $i ]; then
               chmod 755 $i/*
            fi
         done
         popd > /dev/null 2>&1 
      else
         if [ "$IS_BUNDLE_WORKSPACE" == "true" ]; then
            if [ "$OVERWRITE_WORKSPACE_SPECIFIED" == "true" ]; then
               pushd $PADOGRID_WORKSPACE/bundles > /dev/null 2>&1 
               echo git clone $GITHUB_USER_HOME/${BUNDLE_FILE_PATH}.git 
               git clone $GITHUB_USER_HOME/${BUNDLE_FILE_PATH}.git > /dev/null 2>&1
               popd > /dev/null 2>&1
               GIT_DIR=$PADOGRID_WORKSPACE/bundles/$BUNDLE_NAME
            else
               pushd $PADOGRID_WORKSPACES_HOME > /dev/null 2>&1 
               echo git clone $GITHUB_USER_HOME/${BUNDLE_FILE_PATH}.git $REPO_NAME
               git clone $GITHUB_USER_HOME/${BUNDLE_FILE_PATH}.git $REPO_NAME> /dev/null 2>&1
               popd > /dev/null 2>&1 
            fi
         else
            pushd $PADOGRID_WORKSPACE/bundles > /dev/null 2>&1 
            echo git clone $GITHUB_USER_HOME/${BUNDLE_FILE_PATH}.git 
            git clone $GITHUB_USER_HOME/${BUNDLE_FILE_PATH}.git > /dev/null 2>&1
            popd > /dev/null 2>&1
         fi
         if [ ! -d "$GIT_DIR" ]; then
            echo -e >&2 "${CLightRed}ERROR:${CNone} The specified bundle does not exist for the user [$GITHUB_USER]."
            exit 1
         fi
         pushd $GIT_DIR > /dev/null 2>&1 
         if [ "$BRANCH" != "" ]; then
            BRANCH_IN_REMOTE=$(git ls-remote --heads origin ${BRANCH})
            if [[ -z ${BRANCH_IN_REMOTE} ]]; then
               echo -e >&2 "${CLightRed}ERROR:${CNone} The specified branch does not exist: [$BRANCH]. Command aborted."
               exit 1
            fi
            git checkout $BRANCH
         elif [ "$TAG" != "" ]; then
            TAG_IN_REMOTE=$(git ls-remote --tags origin ${TAG})
            if [[ -z ${TAG_IN_REMOTE} ]]; then
               echo -e >&2 "${CLightRed}ERROR:${CNone} The specified tag does not exist: [$TAG]. Command aborted."
               exit 1
            fi
            git checkout $TAG
         fi
         git pull
         if [ "$IS_BUNDLE_WORKSPACE" == "false" ]; then
            mvn package
         fi
         popd > /dev/null 2>&1 
      fi
      if [ "$IS_BUNDLE_WORKSPACE" == "true" ]; then
         WORKSPACE_PATH=$PADOGRID_WORKSPACES_HOME/$WORKSPACE_NAME
         if [ "$OVERWRITE_WORKSPACE_SPECIFIED" == "true" ]; then
            pushd $"$GIT_DIR" > /dev/null 2>&1 
            rm -rf $(find . -name ".git*") > /dev/null 2>&1
            rm -f pom.xml > /dev/null 2>&1
            rm -f assembly-descriptor.xml > /dev/null 2>&1
            rm -f README_HEADER.md > /dev/null 2>&1
            popd > /dev/null 2>&1 
            INIT_WORKSPACE_EXISTS="false"
            if [ -f "$GIT_DIR/.init_workspace.sh" ]; then
               echo -e "${CHighlight}Overwriting current workspace's .init_workspace.sh...${CNone}"
               INIT_WORKSPACE_EXISTS="true"
            fi
            cp -r $GIT_DIR/. "$WORKSPACE_PATH/"
            rm -rf $GIT_DIR
            if [ "$INIT_SPECIFIED" == "true" ] && [ "$INIT_WORKSPACE_EXISTS" == "true" ] && [ -f "$WORKSPACE_PATH/.init_workspace.sh" ]; then
               pushd $"$WORKSPACE_PATH" > /dev/null 2>&1 
               . .init_workspace.sh "$WORKSPACE_NAME"
               popd > /dev/null 2>&1 
            fi
            echo ""
            if [ "$BRANCH_TAG_RELEASE" != "" ]; then
               echo "Branch/Tag/Release: $BRANCH_TAG_RELEASE"
               echo ""
            fi
            echo "Bundle workspace updated. Switch workspace by executing the following command:"
         else
            TEMP_WORKSPACE_DIR=$PADOGRID_WORKSPACES_HOME/__ws-${WORKSPACE_NAME}
            # Copy the workspace files
            if [ "$PRODUCT_HOME" == "" ]; then
               create_workspace -quiet -name __ws-${WORKSPACE_NAME} -headless > /dev/null
            else
               create_workspace -quiet -name __ws-${WORKSPACE_NAME} -product $PRODUCT_HOME -headless > /dev/null
            fi
            rm -rf "$TEMP_WORKSPACE_DIR"/clusters/*
            cp -r "$TEMP_WORKSPACE_DIR"/* "$GIT_DIR"/
            cp "$TEMP_WORKSPACE_DIR"/.addonenv.sh "$GIT_DIR"/
            sed -e "s/__ws-${WORKSPACE_NAME}/${WORKSPACE_NAME}/" "$TEMP_WORKSPACE_DIR/vmenv.sh" > "$GIT_DIR/vmenv.sh"
            rm -rf "$TEMP_WORKSPACE_DIR"

            if [ "$WORKSPACE_SPECIFIED" == "true" ]; then
               # Remove build files including git 
               if [ -d $PADOGRID_WORKSPACES_HOME/$WORKSPACE_NAME ]; then
                  pushd $PADOGRID_WORKSPACES_HOME/$WORKSPACE_NAME > /dev/null 2>&1 
                  rm -rf $(find . -name ".git*") > /dev/null 2>&1
                  rm -f pom.xml > /dev/null 2>&1
                  rm -f assembly-descriptor.xml > /dev/null 2>&1
                  rm -f README_HEADER.md > /dev/null 2>&1
                  popd > /dev/null 2>&1 
               fi
            fi

            CLUSTERS=$(list_clusters -workspace $WORKSPACE_NAME)
            WORKSPACE_PATH=$PADOGRID_WORKSPACES_HOME/$WORKSPACE_NAME
            createClusterEnv
            if [ "$INIT_SPECIFIED" == "true" ] && [ -f "$WORKSPACE_PATH/.init_workspace.sh" ]; then
               pushd $"$WORKSPACE_PATH" > /dev/null 2>&1 
               . .init_workspace.sh "$WORKSPACE_NAME"
               popd > /dev/null 2>&1 
            fi

            echo ""
            if [ "$BRANCH_TAG_RELEASE" != "" ]; then
               echo "Branch/Tag/Release: $BRANCH_TAG_RELEASE"
               echo ""
            fi
            echo "Bundle workspace created. Switch workspace by executing the following command:"
         fi

         echo -e "   ${CLightGreen}switch_workspace $REPO_NAME ${CNone}"
         echo ""
         exit
      else
         mv $GIT_DIR/target/assembly/$TARBALL $PADOGRID_WORKSPACE/bundles
         rm -rf $GIT_DIR
         if [ -f $TARBALL_PATH ]; then
            BUNDLE_FILE_PATH=$TARBALL_PATH
         else
            echo -e >&2 "${CLightRed}ERROR:${CNone} File not found. Command aborted."
            exit 1
         fi
      fi
   else
      BUNDLE_FILE_PATH=$TARBALL_PATH
   fi
fi

if [ ! -f $BUNDLE_FILE_PATH ]; then
   echo >&2 "----------------------------------------------------------------"
   echo >&2 "WORKSPACE: $PADOGRID_WORKSPACE"
   echo -e >&2 "    ${CLightRed}ERROR:${CNone} The specified file not found. Command aborted."
   echo >&2 "----------------------------------------------------------------"
   exit 1 
fi

# Set workspace and its path
if [ "$WORKSPACE_NAME" != "default" ]; then
   WORKSPACE=$WORKSPACE_NAME
   WORKSPACE_PATH="$PADOGRID_WORKSPACES_HOME/$WORKSPACE_NAME"
else
   WORKSPACE=$(basename "$PADOGRID_WORKSPACE")
   WORKSPACE_PATH="$PADOGRID_WORKSPACE"
fi

# Display warning message and backup if the workspace exists
if [ -d "$WORKSPACE_PATH" ] && [ "$PREVIEW" == "false" ]; then
   if [ "$QUIET" == "false" ]; then
      echo ""
      echo "        WORKSPACE: $WORKSPACE_PATH"
      echo "Bundle to Install: $BUNDLE_FILE_PATH"
      echo ""
      echo -e "${CBrownOrange}WARNING:${CNone}"
      echo "   This command installs the specified bundle in the existing workspace. Any"
      echo "   conflicting files will be overwritten with the files in the bundle. Note that"
      echo "   as a safety measure, it will automatically back up the padogrid workspace"
      echo "   in the 'bundles' directory before installing the specified bundle."
      echo "Do you want to continue?"
      echo "(Enter 'continue' + Enter to continue the cluster removal, other keys to abort.)"
      read INPUT
      if [ "$INPUT" != "continue" ]; then
         echo "Bundle installation aborted."
         exit
      fi
   fi

   # Backup the entire workspace
   BUNDLE_DISPLAY_MESSAGE="Backup Bundle Created:"
   echo ""
   echo "BACKUP"
   echo "------"
   $SCRIPT_DIR/create_bundle -workspace $WORKSPACE -all -quiet
fi

# 
# Find all pods, clusters and apps in the bundle
#
# Find all pods
PODS=""
for i in `tar tzvf $BUNDLE_FILE_PATH | sed  -e 's/^.* clusters\/.*//' -e 's/^.* apps\/.*//' -e 's/^.* k8s\/.*//' -e 's/^.* docker\/.*//' -e 's/^.* pods\//pods\//'`; do
   if [[ $i == pods/* ]]; then
      str=${i#pods/}
      pod=$(echo $str | sed 's/\/.*$//')
      if [ "$pod" != "" ] && [[ "$PODS" != *"$pod"* ]]; then
         PODS="$PODS $pod"
      fi
   fi
done

# Find all clusters
CLUSTERS=""
for i in `tar tzvf $BUNDLE_FILE_PATH | sed  -e 's/^.* pods\/.*//' -e 's/^.* apps\/.*//' -e 's/^.* k8s\/.*//' -e 's/^.* docker\/.*//' -e 's/^.* clusters\//clusters\//'`; do
   if [[ $i == clusters/* ]]; then
      str=${i#clusters/}
      cluster=$(echo $str | sed 's/\/.*$//')
      if [ "$cluster" != "" ] && [[ "$CLUSTERS" != *"$cluster"* ]]; then
         CLUSTERS="$CLUSTERS $cluster"
      fi
   fi
done

# Find all apps
APPS=""
for i in `tar tzvf $BUNDLE_FILE_PATH | sed  -e 's/^.* pods\/.*//' -e 's/^.* clusters\/.*//' -e 's/^.* k8s\/.*//' -e 's/^.* docker\/.*//' -e 's/^.* apps\//apps\//'`; do
   if [[ $i == apps/* ]]; then
      str=${i#apps/}
      app=$(echo $str | sed 's/\/.*$//')
      if [ "$app" != "" ] && [[ "$APPS" != *"$app"* ]]; then
         APPS="$APPS $app"
      fi
   fi
done

# Find all kubernetes
K8S="" 
for i in `tar tzvf $BUNDLE_FILE_PATH | sed  -e 's/^.* pods\/.*//' -e 's/^.* clusters\/.*//' -e 's/^.* apps\/.*//' -e 's/^.* docker\/.*//' -e 's/^.* k8s\//k8s\//'`; do
   if [[ $i == k8s/* ]]; then
      str=${i#k8s/}
      k8s=$(echo $str | sed 's/\/.*$//')
      if [ "$k8s" != "" ] && [[ "$K8S" != *"$k8s"* ]]; then
         K8S="$K8S $k8s"
      fi
   fi
done

# Find all dockers
DOCKERS="" 
for i in `tar tzvf $BUNDLE_FILE_PATH | sed  -e 's/^.* pods\/.*//' -e 's/^.* clusters\/.*//' -e 's/^.* apps\/.*//' -e 's/^.* k8s\/.*//' -e 's/^.* docker\//docker\//'`; do
   if [[ $i == docker/* ]]; then
      str=${i#docker/}
      docker=$(echo $str | sed 's/\/.*$//')
      if [ "$docker" != "" ] && [[ "$DOCKERS" != *"$docker"* ]]; then
         DOCKERS="$DOCKERS $docker"
      fi
   fi
done

# Create workspace if it does not exist
if [ ! -d "$WORKSPACE_PATH" ]; then
   create_workspace -name $WORKSPACE_NAME -product $PRODUCT_HOME -quiet > /dev/null
   WORKSPACE_CREATED="true"
else
   WORKSPACE_CREATED="false"
fi

#
# Install the specified bundle
# 
if [ "$PREVIEW" == "true" ]; then
   tar -tzvf $BUNDLE_FILE_PATH
   echo -e "${CBrownOrange}Bundle Preview Only (Not Installed)${CNone}"
else
   tar -C $WORKSPACE_PATH -xzvf $BUNDLE_FILE_PATH
   createClusterEnv
fi

echo ""
if [ "$PREVIEW" == "true" ]; then
   echo "PREVIEW"
   echo "-------"
else
   echo "INSTALLED"
   echo "---------"
fi

if [ "$PREVIEW" == "true" ]; then
   echo "      Cluster Type: $CLUSTER_TYPE"
   if [ "$DOWNLOAD" == "true" ]; then
   echo " Downloaded Bundle: $BUNDLE_FILE_PATH"
   else
   echo "            Bundle: $BUNDLE_FILE_PATH"
   fi
   echo "Branch/Tag/Release: $BRANCH_TAG_RELEASE"
   echo "   Preiview Pod(s):$PODS"
   echo "Preview Cluster(s):$CLUSTERS"
   echo "   Preview Apps(s):$APPS"
   echo "    Preview Docker:$DOCKERS"
   echo "      Preiview K8S:$K8S"
else
   echo "           WORKSPACE: $WORKSPACE_PATH"
   echo "        Cluster Type: $CLUSTER_TYPE"
   echo "              Bundle: $BUNDLE_FILE_PATH"
   echo "  Branch/Tag/Release: $BRANCH_TAG_RELEASE"
   echo "    Installed Pod(s):$PODS"
   echo "Installed Cluster(s):$CLUSTERS"
   echo "    Installed App(s):$APPS"
   echo "    Installed Docker:$DOCKERS"
   echo "       Installed K8S:$K8S"
   echo ""
   echo "The specified bundle extracted and installed."
fi

if [ "$WORKSPACE_CREATED" == "true" ]; then
   echo ""
   echo "Bundle workspace created. Switch workspace by executing the following command:"
   echo -e "   ${CLightGreen}switch_workspace $WORKSPACE_NAME ${CNone}"
fi
echo ""
